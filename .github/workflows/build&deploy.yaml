name: Build, Push and Deploy

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]

env:
  APP_NAME: nginx-test-app
  DOCKER_REPO: makaron7321/nginx-test-app
  NAMESPACE: monitoring
  CONTAINER_PORT: 80

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_tag.outputs.image_tag }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to DockerHub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Determine Docker tags
      id: set_tag
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          # For tags: use the tag name (v1.0.0)
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "image_tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "TAGS=${{ env.DOCKER_REPO }}:$TAG_NAME,${{ env.DOCKER_REPO }}:latest" >> $GITHUB_ENV
        else
          # For branches: use commit SHA and latest
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "image_tag=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "TAGS=${{ env.DOCKER_REPO }}:$SHORT_SHA,${{ env.DOCKER_REPO }}:latest" >> $GITHUB_ENV
        fi

    - name: Build and push Docker image
      run: |
        echo "Building image with tags: $TAGS"
        docker build -t ${{ env.DOCKER_REPO }} .
        
        # Split tags and push each
        IFS=',' read -ra TAG_ARRAY <<< "$TAGS"
        for tag in "${TAG_ARRAY[@]}"; do
          docker tag ${{ env.DOCKER_REPO }} $tag
          docker push $tag
          echo "Pushed: $tag"
        done

    - name: Output image info
      run: |
        echo "Image tags: $TAGS"
        echo "Primary tag: ${{ steps.set_tag.outputs.image_tag }}"

  deploy-to-k8s:
    needs: build-and-push
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Kubernetes tools
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        kubectl version --client

    - name: Configure Kubernetes access
      run: |
        mkdir -p ~/.kube
        echo '${{ secrets.KUBECONFIG }}' > ~/.kube/config
        chmod 600 ~/.kube/config
        kubectl config set-cluster default --server=https://89.169.159.219:6443 --insecure-skip-tls-verify=true
        kubectl cluster-info

    - name: Extract tag version
      run: echo "TAG_VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV

    - name: Deploy to Kubernetes
      run: |
        # Create namespace if not exists
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Create or update deployment with specific tag
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${{ env.APP_NAME }}
          namespace: ${{ env.NAMESPACE }}
          labels:
            app: ${{ env.APP_NAME }}
            version: ${{ env.TAG_VERSION }}
        spec:
          replicas: 1
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 0
          selector:
            matchLabels:
              app: ${{ env.APP_NAME }}
          template:
            metadata:
              labels:
                app: ${{ env.APP_NAME }}
                version: ${{ env.TAG_VERSION }}
            spec:
              containers:
              - name: ${{ env.APP_NAME }}
                image: ${{ env.DOCKER_REPO }}:${{ env.TAG_VERSION }}
                ports:
                - containerPort: ${{ env.CONTAINER_PORT }}
                imagePullPolicy: Always
                livenessProbe:
                  httpGet:
                    path: /
                    port: ${{ env.CONTAINER_PORT }}
                  initialDelaySeconds: 5
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /
                    port: ${{ env.CONTAINER_PORT }}
                  initialDelaySeconds: 2
                  periodSeconds: 5
        EOF

        # Create or update service
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: ${{ env.APP_NAME }}-service
          namespace: ${{ env.NAMESPACE }}
        spec:
          selector:
            app: ${{ env.APP_NAME }}
          ports:
          - protocol: TCP
            port: 80
            targetPort: ${{ env.CONTAINER_PORT }}
          type: ClusterIP
        EOF

    - name: Verify deployment
      run: |
        echo "Deploying version: ${{ env.TAG_VERSION }}"
        echo "=== Deployments ==="
        kubectl get deployments -n ${{ env.NAMESPACE }} -o wide
        echo "=== Pods ==="
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
        echo "=== Services ==="
        kubectl get services -n ${{ env.NAMESPACE }}
        echo "=== Deployment status ==="
        kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --timeout=120s
